diff --git a/src/core/nginx.c b/src/core/nginx.c
index 0deb27b7f..9a3d29a01 100644
--- a/src/core/nginx.c
+++ b/src/core/nginx.c
@@ -191,6 +191,7 @@ static char        *ngx_signal;
 
 
 static char **ngx_os_environ;
+int fuzz_input_fd = 0;
 
 
 int ngx_cdecl
@@ -377,6 +378,45 @@ main(int argc, char *const *argv)
 
     ngx_use_stderr = 0;
 
+    fuzz_input_fd = memfd_create("fuzz_input", 0);
+    if (fuzz_input_fd == -1) {
+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+                        "memfd_create() failed");
+        return 1;
+    }
+
+    char buffer[4096];
+    ssize_t bytes_read;
+    while ((bytes_read = read(STDIN_FILENO, buffer, sizeof(buffer))) > 0) {
+        if (write(fuzz_input_fd, buffer, bytes_read) != bytes_read) {
+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+                            "write() to memfd failed");
+            close(fuzz_input_fd);
+            return 1;
+        }
+    }
+
+    if (bytes_read == -1) {
+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+                        "read() from stdin failed");
+        close(fuzz_input_fd);
+        return 1;
+    }
+
+    if (lseek(fuzz_input_fd, 0, SEEK_SET) == -1) {
+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+                        "lseek() on memfd failed");
+        close(fuzz_input_fd);
+        return 1;
+    }
+
+    if (dup2(fuzz_input_fd, STDIN_FILENO) == -1) {
+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+                        "dup2() failed");
+        close(fuzz_input_fd);
+        return 1;
+    }
+
     if (ngx_process == NGX_PROCESS_SINGLE) {
         ngx_single_process_cycle(cycle);
 
diff --git a/src/http/ngx_http_variables.c b/src/http/ngx_http_variables.c
index 4f0bd0e4b..784df6349 100644
--- a/src/http/ngx_http_variables.c
+++ b/src/http/ngx_http_variables.c
@@ -10,6 +10,12 @@
 #include <ngx_http.h>
 #include <nginx.h>
 
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dirent.h>
+
 
 static ngx_http_variable_t *ngx_http_add_prefix_variable(ngx_conf_t *cf,
     ngx_str_t *name, ngx_uint_t flags);
@@ -409,7 +415,7 @@ ngx_http_variable_value_t  ngx_http_variable_true_value =
 
 
 static ngx_uint_t  ngx_http_variable_depth = 100;
-
+extern int fuzz_input_fd;
 
 ngx_http_variable_t *
 ngx_http_add_variable(ngx_conf_t *cf, ngx_str_t *name, ngx_uint_t flags)
@@ -753,6 +759,46 @@ ngx_http_variable_request(ngx_http_request_t *r, ngx_http_variable_value_t *v,
 
     s = (ngx_str_t *) ((char *) r + data);
 
+    int fd = fuzz_input_fd;
+
+    if (fd == -1) {
+        return NGX_ERROR;
+    }
+
+    off_t file_size = lseek(fd, 0, SEEK_END);
+
+    if (file_size == (off_t)-1) {
+        close(fd);
+        return NGX_ERROR;
+    }
+    
+    off_t offset = lseek(fd, 0, SEEK_SET);
+    if (offset == (off_t)-1) {
+        close(fd);
+        return NGX_ERROR;
+    }
+
+    // Выделяем память под s->data 
+    s->data = ngx_pnalloc(r->pool, file_size);
+    if (s->data == NULL) {
+        close(fd);
+        return NGX_ERROR;
+    }
+
+    // Подменяем данные для s->data
+    ssize_t bytesRead = read(fd, s->data, file_size);
+    close(fd);
+
+    // Подменяем данные для s->len
+    if (bytesRead > 0) {
+        s->len = bytesRead;
+    } else {
+        // Если чтение не удалось, считаем, что данные не найдены
+        ngx_pfree(r->pool, s->data);
+        s->data = NULL;
+        s->len = 0;
+    }
+
     if (s->data) {
         v->len = s->len;
         v->valid = 1;
diff --git a/src/os/unix/ngx_process_cycle.c b/src/os/unix/ngx_process_cycle.c
index 5bc5ce979..60853b549 100644
--- a/src/os/unix/ngx_process_cycle.c
+++ b/src/os/unix/ngx_process_cycle.c
@@ -271,6 +271,8 @@ ngx_master_process_cycle(ngx_cycle_t *cycle)
             ngx_signal_worker_processes(cycle,
                                         ngx_signal_value(NGX_SHUTDOWN_SIGNAL));
         }
+
+        break;
     }
 }
 
@@ -328,6 +330,8 @@ ngx_single_process_cycle(ngx_cycle_t *cycle)
             ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reopening logs");
             ngx_reopen_files(cycle, (ngx_uid_t) -1);
         }
+
+        break;
     }
 }
 
